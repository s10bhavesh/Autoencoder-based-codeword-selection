# -*- coding: utf-8 -*-
"""Autoencoder_3x3_with_max_codewords_90.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P3CnA4-r6cArvhFqjOxaPGosDexY8Gr4
"""

# ----------- Importing all the libraries -----------------------------
import numpy as np
import tensorflow as tf
from keras.layers import Input, Dense, GaussianNoise, Dropout
from keras.models import Model
from keras import regularizers
from tensorflow.keras.layers import BatchNormalization, Lambda
from keras.optimizers import Adam, SGD
from keras import backend as K
import sys
import math as m
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
from sklearn.model_selection import train_test_split

# tf.random.set_seed(3)
# from numpy.random import seed
# seed(3)

# Parameters
M = 4  # no of possible symbols (e,g. 0,1,2,3)
k = int(np.log2(M))  # no of bits to represent all the symbols
n_channel = 2  # no of channels
bits_channel = k / n_channel  # no of bits per channel
Frequency = 5.8 * (10**9)  # Frequency in GHz
c = 3 * (10**8)  # speed of light
Lambda = c / Frequency
insertion_loss = np.power(10, (3 / 10))  # insertion loss as 3db
df = Lambda / 2
EbNo_train = np.power(10, (8 / 10))  #  coverted 10 db of EbNo
# EbNo_train = 5.01187 #  coverted 7 db of EbNo
No_codebooks = 3
angle_count = 0
cnt_ebno = 0
print(insertion_loss)
print(f"M:{M}, k:{k}, n_channel:{n_channel}, R:{bits_channel}")

# No rows and columns of the RIS plate
RIS_ROW = 3
RIS_COL = 3
RIS_element = RIS_ROW * RIS_COL
RIS_element

batch_size = 32

# Angles of elevation and azimuth for each elements
theta_i = -27.5  # Eleveation angle of incidence
theta_d = -27.5  # Eleveation angle of reflection (two degrees were best : 84 & 90 )
phi_i = 90  # Azimuth angle of incidence
angles = []

for i in np.arange(90, 181, 5):  # start, end and gap
    angles.append(i)  # theta d varies for every 6 degrees in the
phi_d = np.array(angles)
print(phi_d)

# Total Number of training symbols
N = 10000  # No of Training sample size
input = np.random.randint(M, size=N)  # Generate M no of random numbers
# h_ri = np.multiply((1/np.sqrt(2)), np.vectorize(complex)(np.random.rand(RIS_element),np.random.rand(RIS_element)))
# print(alpha)


def Channels(theta, phi):
    PHI = df * m.sin(m.radians(phi)) * m.cos(m.radians(theta)) / Lambda
    PSI = df * m.sin(m.radians(theta)) / Lambda

    angle_1 = 2 * m.pi * PHI
    angle_2 = 2 * m.pi * PSI

    arr_1 = []
    arr_2 = []

    for i in range(RIS_ROW):
        ang = angle_1 * i
        arr_1.append(tf.math.exp(complex(0, ang)))
    M_1 = tf.reshape(tf.convert_to_tensor(arr_1), [RIS_ROW, 1])

    for i in range(RIS_COL):
        ang = angle_2 * i
        arr_2.append(tf.math.exp(complex(0, ang)))
    M_2 = tf.reshape(tf.convert_to_tensor(arr_2), [RIS_COL, 1])

    operator = tf.linalg.LinearOperatorKronecker(
        [
            tf.linalg.LinearOperatorFullMatrix(M_1),
            tf.linalg.LinearOperatorFullMatrix(M_2),
        ]
    )
    alpha = tf.convert_to_tensor(
        np.multiply((1 / np.sqrt(2)), np.vectorize(complex)(1, 1))
    )

    channel_value = tf.multiply(alpha, operator.to_dense())
    return channel_value


# h_tr and h_rx are the channels from the transmitter to RIS and from RIS to Receiver
h_tr = Channels(theta_i, phi_i)
h_recev = Channels(theta_d, 90)

# def channel_ri():
#   global angle_count
#   global h_ri
#   if angle_count >= 0 and angle_count <int(len(phi_d)):
#     h_ri = Channels(theta_d, phi_d[angle_count])
#     angle_count += 1
#   else :
#     angle_count = 0
#     channel_ri()
#   return h_ri

# **Codebook Generation**

# Generating a codebook for **8x4 RIS** plate with lambda/2 as the distance between the two elements. so, considering origin at the center of the RIS plate, we have calculated the co-ordinates of the all the elements of RIS. For each of the Element we have calculated the angle of incidence and reflection using the two angles '***theta***' and '***phi***' as angle of elevtion and azimuth. The difference of angle of incidence and reflection is a phase shift of that particular element. similarly, for all the element of the RIS plate and that is what a codebook is.


from itertools import product

x = [
    [list(i[x : x + RIS_ROW]) for x in range(0, len(i), RIS_ROW)]
    for i in product(["0", "180"], repeat=RIS_ROW * RIS_COL)
]
codewords = np.array(x, dtype="int64")

# Plotting all the codebooks
# sns.set()
# # f, ax = plt.subplots(figsize=(8, 8))
# colors = ["gray", "lightgray"]
# cmap = LinearSegmentedColormap.from_list('Custom', colors, len(colors))
# for i in codewords:
# # for i in values:
#   phase = np.array(i)
#   # print(phase)
#   f, ax = plt.subplots(figsize=(3,3))
#   ax = sns.heatmap(phase, cmap = cmap, square = True, linewidth=0.5, cbar_kws ={"shrink": .5})
#   # sns.heatmap(phase, cmap="PiYG", linewidth=.5, vmin = -180, vmax = 180)
#   # sns.heatmap(phase, linewidth=.5, vmin = -180, vmax = 180)

#   # plt.show()
#   colorbar = ax.collections[0].colorbar
#   # colorbar.set_ticks([22.5,67.5,112.5,157.5,-22.5,-67.5,-112.5,-157.5])
#   colorbar.set_ticks([0, 180])

#   colorbar.set_ticklabels(['0','180'])
#   plt.show()

codebook = list()
unique_codes = [146, 338, 170]
# [146, 338, 170]
for i in unique_codes:
    codebook.append(codewords[i])
codebook = np.array(codebook)

# **Channel (h_tr : From Transmitter to RIS

# Complex Multiplication function
def Channel_h_tr(tensor):
    htr = tf.dtypes.cast(tf.reshape(tensor[0], [1, RIS_element]), tf.complex64)
    X = tensor[1]
    real = X[:, 0:1]
    imag = X[:, 1:]
    x = tf.complex(real, imag)

    cmplx_multiply = tf.math.multiply(x, htr)

    multi_real = tf.math.real(cmplx_multiply)
    multi_cmplx = tf.math.imag(cmplx_multiply)

    X_RIS = tf.dtypes.cast(
        tf.concat([multi_real, multi_cmplx], 1, name="concat"), tf.float32
    )
    return X_RIS


# # **Codeword Activation**

# In codeword activation book, phases are either 0 or 180 degree. we need to convert it to the complex values.

# ```
# e^(j*phase) = cos(phase)+jsin(phase)          ----------(1)
# Y_RIS = [e^(j*phase)]*[k*x_RIS]               ----------(2)
# ```

# This comlex values for RIS elements will be multilied with the x_RIS to give Y_RIS as the outut.

#

import math as m


def Codeword_Activation(tensor):
    codebook_index = tensor[0]
    global count
    count = []
    count.append(codebook_index)

    X_RIS = tensor[1]
    x_real = X_RIS[:, 0:RIS_element]
    x_img = X_RIS[:, RIS_element:]
    x_ris = tf.complex(x_real, x_img)

    Index = codebook_index[0:]
    Codebook = tf.convert_to_tensor(codebook.reshape(No_codebooks, RIS_element))
    code = tf.dtypes.cast(tf.gather(Codebook, Index), tf.float32)
    rad_to_deg = m.pi / 180
    code_radian = tf.math.scalar_mul(rad_to_deg, code)

    phases = tf.complex(tf.math.cos(code_radian), tf.math.sin(code_radian))

    Y_RIS = tf.math.scalar_mul(insertion_loss, phases)
    RIS = tf.math.multiply(x_ris, Y_RIS)

    r = tf.math.real(RIS)
    i = tf.math.imag(RIS)

    RIS = tf.dtypes.cast(tf.concat([r, i], 1, name="concat"), tf.float32)

    return RIS


# # **Channel (h_rx : From RIS to Receiver )**

# This is the channel h_ri(receiver end). The h_ri is of type *Complex* and of size *No_of_element* in RIS. This customied layer will multiply h_ri with the RIS output which will generate symbol with addition of Additive White Gaussian Noise(AWGN).


# ```
# y(x) = h_rx.T * Y_RIS(x) + n_r
# here,
# h_rx.T = Transpose of the h_rx
# Y_RIS(x) = Output of the RIS neural network
# n_r = Additive white Gaussian Noise(AWGN noise)
# ```


def Channel_h_rx(tensor):
    h_rx = tf.dtypes.cast(tf.reshape(tensor[0], [RIS_element, 1]), tf.complex64)
    Y_RIS = tensor[1]
    y_real = Y_RIS[:, 0:RIS_element]
    y_img = Y_RIS[:, RIS_element:]
    y_ris = tf.complex(y_real, y_img)

    y_x = tf.linalg.matmul(y_ris, h_rx)
    y_x_real = tf.math.real(y_x)
    y_x_cmplx = tf.math.imag(y_x)

    y_x = tf.dtypes.cast(tf.concat([y_x_real, y_x_cmplx], 1, name="concat"), tf.float32)

    return y_x


# RIS Input


def RIS_Input(tensors):
    RIS_h_rx = tensors[0]
    Channel_1 = tensors[1]
    RIS_h_rx = tf.reshape(
        tf.dtypes.cast(
            tf.concat(
                [tf.math.real(RIS_h_rx), tf.math.imag(RIS_h_rx)], 0, name="concat"
            ),
            tf.float32,
        ),
        [1, 2 * RIS_element],
    )
    RIS_h_rx = tf.repeat(RIS_h_rx, repeats=tf.shape(Channel_1)[0], axis=0)
    RIS_input = tf.dtypes.cast(
        tf.concat([Channel_1, RIS_h_rx], 1, name="concat"), tf.float32
    )
    return RIS_input


# -------------------- Generate the Ebno randomly -------------------


# def generate_EbNo():
#   global cnt_ebno
#   EbNodB_range = list(frange(0,30,1))
#   if cnt_ebno >=0 and cnt_ebno < len(EbNodB_range):
#     cnt_ebno += 1
#     return(EbNodB_range[cnt_ebno])
#   else :
#     cnt_ebno = 0
#     generate_EbNo()

# Neural Network For Autoencoder(Model

RIS_input_size = int(RIS_element * 4)

# Neural Network Model for the Autoencoder
input_signal = Input(shape=(M,))

# Encoder as a transmitter
encoded_1 = Dense(M, activation="relu")(input_signal)
encoded_4 = Dense(n_channel, activation="linear")(encoded_1)
encoded = tf.keras.layers.Lambda(
    lambda x: np.sqrt(2) * K.l2_normalize(x, axis=1), name="Normalization"
)(
    encoded_4
)  # L2-Normalization

# Channel multilication X_ris = encoded(shape: 2x1)*h_tr(shape:32x1)
Channel_1 = tf.keras.layers.Lambda(Channel_h_tr, name="Channel_tr")([h_tr, encoded])
RIS_input = tf.keras.layers.Lambda(RIS_Input, name="RIS_Input")([h_recev, Channel_1])

# RIS as a Neural Network
RIS_1 = Dense(RIS_input_size, activation="relu")(
    RIS_input
)  ## also give H_rx as an input to the system
RIS_2 = Dense(RIS_input_size, activation="relu")(RIS_1)
RIS_3 = Dense(RIS_input_size, activation="relu")(RIS_2)
RIS_4 = Dense(RIS_input_size, activation="relu")(RIS_3)
RIS_5 = Dense(RIS_input_size, activation="relu")(RIS_4)
RIS = Dense(No_codebooks, activation="softmax")(RIS_5)

# Customized argmax function that will give the index value of the codebook vector
codebook_index = tf.keras.layers.Lambda(lambda x: K.argmax(x), name="ArgMax_codebook")(
    RIS
)
Y_RIS = tf.keras.layers.Lambda(Codeword_Activation, name="Codebook_activation")(
    [codebook_index, Channel_1]
)

# Channel Multilication y = Y_RIS*h_rx
channel_h_rx = tf.keras.layers.Lambda(Channel_h_rx, name="Channel_rx")([h_recev, Y_RIS])
Gaussian_noise = tf.keras.layers.GaussianNoise(
    m.sqrt(1 / 2 * bits_channel * EbNo_train)
)(channel_h_rx)

# Decoder as a receiver
decoder_1 = Dense(n_channel, activation="relu")(Gaussian_noise)
Decoded = Dense(M, activation="softmax")(decoder_1)

Autoencoder = Model(input_signal, Decoded)
Autoencoder.compile(
    optimizer=Adam(learning_rate=0.01),
    loss="categorical_crossentropy",
    metrics=["accuracy"],
)
Autoencoder.summary()

Input_data = tf.one_hot(input, M, dtype=tf.int64)

X_train, X_val, y_train, y_val = train_test_split(input, input, train_size=0.70)

print(X_train.dtype, X_val.dtype)
print(y_train.shape, y_val.shape)

x_train = tf.one_hot(X_train, M, dtype=tf.float32)
y_train = tf.one_hot(y_train, M, dtype=tf.float32)
x_val = tf.one_hot(X_val, M, dtype=tf.float32)
y_val = tf.one_hot(y_val, M, dtype=tf.float32)
print(x_train.dtype)
print(x_train[0].shape, x_val.shape)

# Training the model

# for i in range(len(phi_d)):
# print(f"{i} iteration of training")
model = Autoencoder.fit(
    x_train, y_train, epochs=45, batch_size=batch_size, validation_data=(x_val, y_val)
)

import matplotlib.pyplot as plt

# summarize history for accuracy
plt.plot(model.history["accuracy"])
plt.plot(model.history["val_accuracy"])
plt.title("model accuracy")
plt.ylabel("accuracy")
plt.xlabel("epoch")
plt.legend(["Train", "Validation"], loc="upper left")
plt.show()

# summarize history for loss
plt.plot(model.history["loss"])
plt.plot(model.history["val_loss"])
plt.title("model loss")
plt.ylabel("loss")
plt.xlabel("epoch")
plt.legend(["Train", "Validation"], loc="upper left")
plt.show()

# Encoder
encoder = Model(input_signal, encoded)
encoder.summary()

ris_input = Input(shape=(RIS_input_size))
ris_1 = Autoencoder.layers[-12](ris_input)
ris_2 = Autoencoder.layers[-11](ris_1)
ris_3 = Autoencoder.layers[-10](ris_2)
ris_4 = Autoencoder.layers[-9](ris_3)
ris_5 = Autoencoder.layers[-8](ris_4)
ris_6 = Autoencoder.layers[-7](ris_5)
ris = Model(ris_input, ris_6)
ris.summary()

# making decoder from full autoencoder
decoded_input = Input(shape=(2,))  # n_channel
deco_3 = Autoencoder.layers[-2](decoded_input)
deco_4 = Autoencoder.layers[-1](deco_3)
Decoder = Model(decoded_input, deco_4)
Decoder.summary()

test_sample = 10000
test = np.random.randint(
    M, size=test_sample
)  # Generate test_sample no of random numbers
Test_data = tf.one_hot(test, M, dtype=tf.int64)
Test_label = test

# for plotting learned consteallation diagram
scatter_plot = []
for i in range(0, M):
    print(i)
    temp = np.zeros(M)
    temp[i] = 1
    print(np.expand_dims(temp, axis=0))
    scatter_plot.append(encoder.predict(np.expand_dims(temp, axis=0)))
scatter_plot = np.array(scatter_plot)
print(scatter_plot.shape)
print(scatter_plot)

# ploting constellation diagram
import matplotlib.pyplot as plt

# import matplotlib.cm as cm

scatter_plot = scatter_plot.reshape(M, 2, 1)
# colors = cm.rainbow(np.linspace(0, 1, len(scatter_plot)))
plt.scatter(scatter_plot[:, 0], scatter_plot[:, 1])
plt.axis((-2.5, 2.5, -2.5, 2.5))
# plt.axis((-10.0,10.0,-10.0,10.0))
plt.grid()
plt.show()


def frange(x, y, jump):
    while x < y:
        yield x
        x += jump


EbNodB_range = list(frange(-15, 20, 1))
# EbNodB_range = list(frange(0,30,0.5))
No_iter = 1
BER_list = []
# BER_list = []
# for i in range(No_iter):
print(f"{i}nd iteration\n")
ber = [None] * len(EbNodB_range)
for n in range(0, len(EbNodB_range)):
    # Ber = []
    EbNo = 10.0 ** (EbNodB_range[n] / 10.0)
    noise_std = np.sqrt(1 / (2 * bits_channel * EbNo))
    noise_mean = 0
    no_errors = 0
    nn = test_sample
    noise = noise_std * np.random.randn(nn, n_channel)

    encoded_signal = encoder.predict(Test_data)  # Encoder prediction
    Channel_1 = Channel_h_tr([h_tr, encoded_signal])  # Channel transmitter(tr)
    RIS_input = RIS_Input([h_recev, Channel_1])  # RIS
    ris_signal = ris.predict(RIS_input)  # RIS Prediction
    codebook_index = K.argmax(ris_signal)  # Argmax
    Y_RIS = Codeword_Activation([codebook_index, Channel_1])  # Codeword Activation
    channel_h_rx = Channel_h_rx([h_recev, Y_RIS])  # Channel receiver (rx)
    final_ris_signal = noise + channel_h_rx  # RIS output
    pred_final_signal = Decoder.predict(final_ris_signal)  # Decoder Prediction
    pred_output = np.argmax(pred_final_signal, axis=1)
    no_errors = pred_output != Test_label
    # no_errors =  no_errors.sum()
    no_errors = no_errors.astype(int).sum()
    ber[n] = no_errors / nn
    print("SNR:", EbNodB_range[n], "BER:", ber[n])
    # print()
    # Ber.append(ber[n])

    # BER_list.append(ber)

# avg_sum = []
# for i in range(len(BER_list[0])):
#   sum = 0
#   for j in range(len(EbNodB_range)):
#     sum += float(BER_list[j][i])
#   avg_sum.append(sum/No_iter)

print(len(BER_list))

np.set_printoptions(threshold=sys.maxsize)
pred_output

# ploting ber curve
import matplotlib.pyplot as plt
from scipy import interpolate

plt.plot(EbNodB_range, ber, "bo", label="Autoencoder(3,3)")
plt.yscale("log")
plt.xlabel("SNR Range")
plt.ylabel("Block Error Rate")
# plt.grid()
plt.legend(loc="upper right", ncol=1)

count

tf.math.bincount(count)

codes, idx = tf.unique(count[0])
codes

# Plotting all the codebooks
sns.set()
# f, ax = plt.subplots(figsize=(8, 8))
colors = ["gray", "lightgray"]
cmap = LinearSegmentedColormap.from_list("Custom", colors, len(colors))
# line = [219,235,435]
for i in codes:
    # for i in values:
    phase = np.array(codebook[i])
    # print(phase)
    f, ax = plt.subplots(figsize=(8, 8))
    ax = sns.heatmap(
        phase, cmap=cmap, square=True, linewidth=0.5, cbar_kws={"shrink": 0.5}
    )
    # sns.heatmap(phase, cmap="PiYG", linewidth=.5, vmin = -180, vmax = 180)
    # sns.heatmap(phase, linewidth=.5, vmin = -180, vmax = 180)

    # plt.show()
    colorbar = ax.collections[0].colorbar
    # colorbar.set_ticks([22.5,67.5,112.5,157.5,-22.5,-67.5,-112.5,-157.5])
    colorbar.set_ticks([0, 180])

    colorbar.set_ticklabels(["0", "180"])
    plt.show()

import pandas as pd

df = pd.DataFrame(data=[EbNodB_range, ber]).T
df.rename(columns={0: "SNR", 1: "BER"}, inplace=True)
df.to_csv("SNR_90.csv")

# import csv
# with open('/content/drive/MyDrive/COMET Project(kh)/Autoencoder/Replicate/Codebook Design/Channel_codes.csv', 'a', encoding='UTF8') as f:
#   writer = csv.writer(f)
#   writer.writerow(row)
